(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{378:function(e,t,a){"use strict";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"specification-dag-json"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification-dag-json"}},[e._v("#")]),e._v(" Specification: DAG-JSON")]),e._v(" "),a("p",[a("strong",[e._v("Status: Descriptive - Final")])]),e._v(" "),a("p",[e._v("DAG-JSON supports the full "),a("RouterLink",{attrs:{to:"/data-model-layer/data-model.html"}},[e._v("IPLD Data Model")]),e._v(".")],1),e._v(" "),a("h2",{attrs:{id:"format"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#format"}},[e._v("#")]),e._v(" Format")]),e._v(" "),a("h3",{attrs:{id:"serialization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#serialization"}},[e._v("#")]),e._v(" Serialization")]),e._v(" "),a("p",[e._v("Codec implementors "),a("strong",[e._v("MUST")]),e._v(" do the following in order to ensure hashes consistently match for the same block data.")]),e._v(" "),a("ul",[a("li",[e._v("Sort object keys by their (UTF-8) encoded representation, i.e. with byte comparisons")]),e._v(" "),a("li",[e._v("Strip whitespace")])]),e._v(" "),a("p",[e._v("This produces the most compact and consistent representation which will ensure that two codecs\nproducing the same data end up with matching block hashes.")]),e._v(" "),a("h3",{attrs:{id:"natively-supported-kinds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#natively-supported-kinds"}},[e._v("#")]),e._v(" Natively supported kinds")]),e._v(" "),a("p",[e._v("All kinds of the IPLD Data Model except Bytes and Link are supported natively by JSON.")]),e._v(" "),a("h4",{attrs:{id:"numbers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#numbers"}},[e._v("#")]),e._v(" Numbers")]),e._v(" "),a("p",[e._v("Numbers are a special case. JSON only has a single number type, though many dynamically typed programming languages (e.g. Python, Ruby, PHP) distinguish between integers and floats when parsing JSON. A number consisting of an optional leading sign and only digits is parsed as integer, if it contains a decimal point, it's parsed as a float. In DAG-JSON the same method is used to represent integers and floats.")]),e._v(" "),a("p",[e._v("Contrary to popular belief, JSON as a format supports Big Integers. It's only\nJavaScript itself that has trouble with them. This means JS implementations\nof DAG-JSON can't use the native JSON parser and serializer if integers bigger\nthan "),a("code",[e._v("2^53 - 1")]),e._v(" should be supported.")]),e._v(" "),a("h3",{attrs:{id:"other-kinds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#other-kinds"}},[e._v("#")]),e._v(" Other kinds")]),e._v(" "),a("p",[e._v("The non-natively supported kinds are wrapped in an object, where the key is a slash ("),a("code",[e._v('"/"')]),e._v(") and the value is the actual kind.")]),e._v(" "),a("h4",{attrs:{id:"bytes-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bytes-kind"}},[e._v("#")]),e._v(" Bytes kind")]),e._v(" "),a("p",[e._v("The Bytes kind is represented as an object with "),a("code",[e._v('"bytes"')]),e._v(" as key and a "),a("a",{attrs:{href:"https://github.com/multiformats/multibase",target:"_blank",rel:"noopener noreferrer"}},[e._v("Multibase"),a("OutboundLink")],1),e._v(" Base64 encoded string as value. The Base64 encoding is the one described in "),a("a",{attrs:{href:"https://tools.ietf.org/html/rfc4648#section-4",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 4648, section 4"),a("OutboundLink")],1),e._v(" without padding, hence the Multibase prefix is "),a("code",[e._v("m")]),e._v(".")]),e._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"/"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"bytes"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" String "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* Multibase Base64 encoded binary */")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("h4",{attrs:{id:"link-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#link-kind"}},[e._v("#")]),e._v(" Link kind")]),e._v(" "),a("p",[e._v("A link is represented as a base encoded CID. CIDv0 and CIDv1 are encoded differently.")]),e._v(" "),a("ul",[a("li",[e._v("CIDv1 is represented as a Multibase Base32 encoded string. The Base32 encoding is the one described in "),a("a",{attrs:{href:"https://tools.ietf.org/html/rfc4648#section-6",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 4648, section 6"),a("OutboundLink")],1),e._v(" without padding, hence the Multibase prefix is "),a("code",[e._v("b")]),e._v(".")]),e._v(" "),a("li",[e._v("CIDv0 is represented in its only possible Base58 encoding. The Base58 encoding is the one described in "),a("a",{attrs:{href:"https://tools.ietf.org/html/draft-msporny-base58",target:"_blank",rel:"noopener noreferrer"}},[e._v("Base58 draft"),a("OutboundLink")],1),e._v(".")])]),e._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"/"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" String "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* Base58 encoded CIDv0 or Multibase Base32 encoded CIDv1 */")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);