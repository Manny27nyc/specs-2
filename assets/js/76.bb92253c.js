(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{437:function(e,t,a){"use strict";a.r(t);var n=a(44),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"nodes-and-kinds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodes-and-kinds"}},[e._v("#")]),e._v(" Nodes and Kinds")]),e._v(" "),a("p",[a("strong",[e._v("Preface: purpose of this document:")])]),e._v(" "),a("p",[e._v("This document is intended for developers of new (or renovating) IPLD libraries.\nIt contains design suggestions based on the experience of building (and rebuilding)\nIPLD libraries in various languages, and reflecting on the lessons learned.\nIt also contains both notes on practical limitations we've found for implementations,\nand reflections on how to express things clearly within the type systems of the\nhost language a library is implemented in (whatever that may be).")]),e._v(" "),a("p",[a("strong",[e._v("Preface: limitations of this document:")])]),e._v(" "),a("p",[e._v("Since this document is aimed at "),a("em",[e._v("new libraries")]),e._v(", it's also implicitly expecting\nthat the new library might be in a "),a("em",[e._v("new language")]),e._v(".\nWe can't presume to know precisely what that language will enable or encourage!\nTherefore, there will be limits to how transferable the advice in this document may be.\nWe do expect that the best way to express IPLD concepts may vary based on\nthe language a library is created in.  We accept this and try to write this\ndocument anyway, and make it as useful as it can be.")]),e._v(" "),a("p",[e._v('These guidelines are written with particular attention to the limitations that\nare typical to strongly typed languages. (Some of the phrasing used reflect\nthis -- we refer to "types", "enumerations", "interfaces", "packages", etc.\nHowever, these concepts can still translate even to languages with varying\namounts of compile-time type checking, and indeed even to those with none.\nWhile the concepts are certainly not identical across all languages,\nwe hope that they\'re close enough to be meaningful to a thoughtful reader.)')]),e._v(" "),a("p",[e._v('We expect that common concepts for IPLD libraries will emerge across many languages,\nand hope that some vocabulary for these concepts is something we can share.\nLoosely and untyped languages may need to interpret these guidelines\nappropriately while extracting the key concepts; but even among languages with\nstricter concepts of compile-time type checking, the meaning of "interface"\ncan vary greatly -- '),a("em",[e._v("all")]),e._v(" readers will need to be ready to use their best judgement.")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"cornerstone-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cornerstone-types"}},[e._v("#")]),e._v(" Cornerstone Types")]),e._v(" "),a("p",[e._v("Your IPLD library should have two cornerstone types:")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("Node")]),e._v(";")]),e._v(" "),a("li",[a("code",[e._v("Kind")]),e._v(".")])]),e._v(" "),a("p",[a("code",[e._v("Node")]),e._v(" should be an interface -- the membership should be open\n(aka, it should be possible for other packages to implement it).")]),e._v(" "),a("p",[a("code",[e._v("Kind")]),e._v(" should be an enumeration -- a fixed set of named members,\nwhich should not be extendable.")]),e._v(" "),a("h2",{attrs:{id:"kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kind"}},[e._v("#")]),e._v(" Kind")]),e._v(" "),a("p",[a("code",[e._v("Kind")]),e._v(" maps very directly onto the definition of\n"),a("RouterLink",{attrs:{to:"/data-model-layer/data-model.html#kinds"}},[e._v("Data Model Kinds")]),e._v(".")],1),e._v(" "),a("p",[a("code",[e._v("Kind")]),e._v(' does not include the Schema layer\'s concept of "struct", etc.')]),e._v(" "),a("p",[a("code",[e._v("Kind")]),e._v(" must be an enum, "),a("strong",[e._v("and not a sum type")]),e._v(".  Attempting to implement\nkind as a sum type conflates it with "),a("code",[e._v("Node")]),e._v(".\n(This may be tempting to try to combine "),a("code",[e._v("Kind")]),e._v(" and "),a("code",[e._v("Node")]),e._v(" into a single\nsum type definition if you're only looking at the Data Model layer,\nbut it is a mistake: both Schema types and Advanced Layouts require\nthe ability to add more implementations of "),a("code",[e._v("Node")]),e._v(", so this conflation\nwill cause cataclysmic problems and force a painful refactor\nas soon as you get to implementing those systems.\nSee the "),a("a",{attrs:{href:"#different-implementors-of-node"}},[e._v("different implementors of Node")]),e._v("\nsection, later in this document, for more information on this.)")]),e._v(" "),a("h2",{attrs:{id:"node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[e._v("#")]),e._v(" Node")]),e._v(" "),a("p",[a("code",[e._v("Node")]),e._v(" is a monomorphized interface for handling data -- in other words,\nwe make all data look and act like a "),a("code",[e._v("Node")]),e._v(", so that we can write all of our\nfunctions against the "),a("code",[e._v("Node")]),e._v(" interface, and have that work for any sort of data.")]),e._v(" "),a("p",[a("code",[e._v("Node")]),e._v(" has functions for examining any of the\n"),a("RouterLink",{attrs:{to:"/data-model-layer/data-model.html#kinds"}},[e._v("Data Model Kinds")]),e._v(".\nFor example, this means "),a("code",[e._v("Node")]),e._v(" must be able to\ndo a key lookup for a map kind,\nprovide an iterator for a list kind,\nor be convertible to a primitive if it's a integer kind.")],1),e._v(" "),a("p",[a("code",[e._v("Node")]),e._v(" is generally implemented by making an interface with the superset of all\nthese methods needed for the various kinds of data.\nSome programming languages may also have a pattern-matching faculty which\nmay make this nicer; feel free to use it (but mind the caveats issued in the\n"),a("a",{attrs:{href:"#kind"}},[e._v("Kind")]),e._v(" section above, and the\n"),a("a",{attrs:{href:"#different-implementors-of-node"}},[e._v("different implementors of Node")]),e._v(" section below:\nthe membership of "),a("code",[e._v("Node")]),e._v(" must remain "),a("em",[e._v("open")]),e._v(";\nyou do "),a("em",[e._v("not")]),e._v(" want to use a sum type with a closed list of concrete members here,\nor it will cause other roadblocks later that "),a("em",[e._v("will")]),e._v(" force a redesign).\nFor languages where this is most straightforwardly implemented by a single\ninterface containing the superset of all necessary methods, many of the methods\nwill error if the "),a("code",[e._v("Node")]),e._v(" refers to information of the wrong kind for that method;\nthis is fine.")]),e._v(" "),a("p",[a("code",[e._v("Node")]),e._v(" should be clear about what sets of methods are valid for acting on it.\nTypically, this is done by a "),a("code",[e._v("Node.Kind()")]),e._v(" method, which should return\na member of the "),a("a",{attrs:{href:"#kind"}},[e._v("Kind")]),e._v(" enum.\nThis information is useful for anyone writing functions which use the "),a("code",[e._v("Node")]),e._v("\ninterface, because it's much more pleasant (and fast) to check the Kind and\nknow which methods can be expected to work than it is to have to probe every\nmethod individually for failure.\n(Again, programming languages with pattern-matching faculties may find\na cleverer way for their compiler and type system to support this.)")]),e._v(" "),a("h3",{attrs:{id:"different-implementors-of-node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#different-implementors-of-node"}},[e._v("#")]),e._v(" different implementors of Node")]),e._v(" "),a("p",[e._v("Though the methods on the "),a("code",[e._v("Node")]),e._v(" interface are defined as those necessary for\nexamining data of the "),a("RouterLink",{attrs:{to:"/data-model-layer/data-model.html#kinds"}},[e._v("Data Model Kinds")]),e._v(",\n"),a("strong",[a("code",[e._v("Node")]),e._v(" is not only implemented by the Data Model")]),e._v(":")],1),e._v(" "),a("ul",[a("li",[e._v("Yes, "),a("code",[e._v("Node")]),e._v(" is implemented by types that just hold basic Data Model info;")]),e._v(" "),a("li",[a("code",[e._v("Node")]),e._v(" is also implemented by "),a("RouterLink",{attrs:{to:"/schemas/advanced-layouts.html"}},[e._v("Advanced Data Layouts")]),e._v(" --\n"),a("ul",[a("li",[e._v("consider a HAMT that spans many separately-serialized chunks of data; it should still be usable as if it's a regular map.")])])],1),e._v(" "),a("li",[a("code",[e._v("Node")]),e._v(" is also implemented by "),a("RouterLink",{attrs:{to:"/schemas/"}},[e._v("Schema-typed Nodes")]),e._v(" --\n"),a("ul",[a("li",[e._v("Both if implemented by a single implementation that evaluates rules at runtime (so, finite count of implementing types and known at core library compile time)...")]),e._v(" "),a("li",[e._v("or if handled by codegen/macros (unknown count / open set of implementors of "),a("code",[e._v("Node")]),e._v("; not known at core library compile time; may be created in other packages that import the core, rather than core importing them!).")])])],1)]),e._v(" "),a("p",[e._v("Even further, some libraries may choose to make even more various\nimplementations of "),a("code",[e._v("Node")]),e._v(" for optimizing performance of specific tasks:\nfor example, a "),a("code",[e._v("Node")]),e._v(' which implements basic Data Model "map" semantics,\nbut using some internal algorithm for memory layout which is known to be\nefficient for certain workloads;\nor for another example, a '),a("code",[e._v("Node")]),e._v(" which is particularly efficient for handling\ndata of one particular serialization codec, and keeps a lazy-loading skip-tree\nover the serialized bytes.\nClearly, neither of these should be the default implementation a library uses,\nbut clearly, both of them should be able to be used transparently,")]),e._v(" "),a("p",[e._v("With all seven (?! indeed, "),a("em",[e._v("seven")]),e._v(") of these different stories,\nwe can consider it conclusive that the "),a("code",[e._v("Node")]),e._v(" interface should be ready\nto support many, many diverse implementors.")]),e._v(" "),a("h3",{attrs:{id:"a-default-implementation-of-node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-default-implementation-of-node"}},[e._v("#")]),e._v(" a default implementation of Node")]),e._v(" "),a("p",[e._v('As an IPLD library author, you may be tempted to make a single, "default"\nimplementation of '),a("code",[e._v("Node")]),e._v(".")]),e._v(" "),a("p",[e._v("Feel free to do so; but be cautious of giving it special privileges.\nTry implementing it in a separate package from your core interfaces: this will\nbe a good exercise to make sure other implementations can later do the same.\n(Since in the order of things you'll do when implementing a new IPLD library,\ncreating this basic default node implementation is likely quite early,\ngoing about it in such a way that it forces design choices you'll need later\nanyway will save you from potentially discovering the need for some costly\nrefactors later!)")]),e._v(" "),a("h2",{attrs:{id:"nodes-vs-nodebuilders"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodes-vs-nodebuilders"}},[e._v("#")]),e._v(" Nodes vs NodeBuilders")]),e._v(" "),a("p",[e._v('If you choose to pursue a distinction between mutable and immutable data\nin the design of your library, it may be useful to create two separate\ninterfaces for each phase of the data\'s lifecycle.\nThese might be called "Node" (for the immutable data)\nand "NodeBuilder" (for the mutating/building phase of the data\'s life).')]),e._v(" "),a("p",[e._v('It is not necessary to have distinct interfaces for this;\na library can also opt to have a mutable concept of "node".\nImmutable interfaces can be particularly well-suited to IPLD data, though;\nit\'s worth considering them.')]),e._v(" "),a("h2",{attrs:{id:"higher-level-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#higher-level-functions"}},[e._v("#")]),e._v(" Higher level functions")]),e._v(" "),a("p",[e._v("Almost all features should be implemented to take "),a("code",[e._v("Node")]),e._v(" arguments,\nand return "),a("code",[e._v("Node")]),e._v(" values.")]),e._v(" "),a("p",[e._v("Traversals and walks can be implemented in this way: e.g.\n"),a("code",[e._v("function walk(start Node, visitorFn func(visited Node))")]),e._v(".")]),e._v(" "),a("p",[e._v("Selectors can be implemented in this way.\n(Continue with the idea above for traversals.)")]),e._v(" "),a("p",[e._v("Transformations can be implemented in this way.\n(Continue with the idea above for traversals.)")]),e._v(" "),a("p",[e._v("Codecs themselves can be implemented this way:\nmarshalling is a traverse over nodes, so "),a("code",[e._v("func marshal(obj Node) -> bytes")]),e._v(",\nand unmarshalling is something like "),a("code",[e._v("func unmarshal(bytes, NodeBuilder) -> Node")]),e._v(".")]),e._v(" "),a("p",[e._v("(Note that if your library has a "),a("code",[e._v("Node")]),e._v("/"),a("code",[e._v("NodeBuilder")]),e._v(" split for immutability purposes,\nthen of course any operation that builds new nodes,\nsuch as transformations or codecs during unmarshalling,\nwill have a "),a("code",[e._v("NodeBuilder")]),e._v(" parameter.\nIf your library has a mutable "),a("code",[e._v("Node")]),e._v(", these function signatures might appear differently.)")]),e._v(" "),a("p",[e._v("By defining all these functions in terms of "),a("code",[e._v("Node")]),e._v(", they can be used the same\nin any of the various contexts described in the\n"),a("a",{attrs:{href:"#different-implementors-of-node"}},[e._v("different implementors of Node")]),e._v(" section:")]),e._v(" "),a("ul",[a("li",[e._v("traversals/selectors/transforms/etc work over various codecs (trivially,\nby transitive property).")]),e._v(" "),a("li",[e._v("traversals/selectors/transforms/etc work regardless of in-memory layouts\nthat may vary per "),a("code",[e._v("Node")]),e._v(" implementation")]),e._v(" "),a("li",[e._v("traversals/selectors/transforms/etc work transparently over ADLs!")]),e._v(" "),a("li",[e._v("traversals/selectors/transforms/etc work transparently over schemas!")])]),e._v(" "),a("p",[e._v("It is also useful to note that by implementing these features over the "),a("code",[e._v("Node")]),e._v("\ninterface, rather than "),a("em",[e._v("in")]),e._v(" the "),a("code",[e._v("Node")]),e._v(" interface, it becomes much more\npossible to implement various kinds of e.g. traversal library\n(perhaps you'll discover two different ways to go about it,\none with better ergonomics, and one with better performance?);\nand it also requires much less code per "),a("code",[e._v("Node")]),e._v(" implementation if things\nlike traversals are implemented from the outside.")])])}),[],!1,null,null,null);t.default=o.exports}}]);